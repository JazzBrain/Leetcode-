### 1. 指针和引用

```c++
1.指针可以为空，引用不可以
2.指针可以有多级
3.引用声明的时候 就必须初始化
4.自增运算含义不同，指针表示下一个变量，引用表示值自增
5.作为函数参数传递时的区别,使用指针的话需要解引用才能对参数做修改,而使用引用可以直接对参数进行修改
  （解引用就是返回内存地址中保存的值）
6.指针可以更换指向的对象或变量，引用不可以
7.指针有属于它自己的空间，引用的大小取决于被引用对象的大小
  
other
  引用参数使用const eg: 
	int a = 9;
	double recube(const double &a);
	recube(a+10);//会创建一个临时变量，如果不是用const会出错;同时也可以防止数据被无意修改

```

### 2. 传参数的时候什么时候用指针，什么时候用引用

```c++
1.对栈空间大小比较敏感（如递归）的时候使用引用。使用引用不需要创建临时变量，开销更小；
2.类对象作为参数传递时使用引用，这是C++类对象传递的标准方式。
3.需要返回函数内局部变量的地址的内存时使用指针。使用指针传参需要开辟内存，用完要记得释放指针。
  
  
指针传递参数本质上是值传递的方式，它所传递的是一个地址值。
在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。
  
other : 引用作为函数参数以及返回值的好处
	作为函数参数：效率高，可以对实参进行修改
  作为返回值：在内存中不产生被返回值的副本
    1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁
    2）不能返回函数内部new分配的内存的引用。

```

### 3. 堆和栈的区别

```c++
1.堆 由程序员释放 一般new delete
  
2.栈速度比堆快
操作系统在底层会对栈提供支持，会分配专门的寄存器存放栈的地址;
而堆的操作是由C/C++函数库提供的，在分配堆内存的时候，需要一定的算法寻找合适的内存大小，并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。
  
3.对于堆，频繁的new/delete会造成大量碎片，使程序效率降低。 对于栈，它是一个先进后出的队列，进出一一对应，不会产生碎片。
  
4.栈是一块连续的内存区域，堆是不连续的
  
5.堆的生长空间向上，地址越来越大；栈的生长空间向下，地址越来越小。---？？？
```

### 4.new和delete是如何实现的，new和malloc的异同

```c++
1.在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。
2.delete会调用对象的析构函数，然后调用free回收内存。
3.new只需要对象名，new还会根据调用对象的构造函数进行初始化,malloc还需要指定出空间
  
补充：被free之后，并不是立即返回给操作系统，因为为了避免频繁的系统调用，free会瘦的内存会被ptmalloc双链表保存起来，当用户下一次申请内存的时候，会从这些内存中返回合适的，同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。
```



### 5.linux下brk、mmap、malloc和new的区别

```

```



### 6.既然有了malloc/free，为什么还要new/delete？

```c++
1.对于内部数据类型，由于其没有构造函数和析构函数的要求，对于内部数据类型来讲，malloc/free和new/delete的作用是等价的，都是用来申请动态内存和释放内存。
2.对于非内部数据对象(eg：类对象)，只用malloc/free无法满足动态对象的要求。这是因为对象在创建的同时需要自动执行构造函数，对象在消亡之前要自动执行析构函数，而由于malloc/free是库函数而不是运算符，不在编译器的控制权限内，也就不能自动执行构造函数和析构函数。因此，不能将执行构造函数和析构函数的任务强加给malloc/free。所以，在c++中需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理和释放内存工作的运算符delete。

```

### 7.C和C++的区别

```c++
1.C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete
2.C面向过程， c++面向对象。c++有封装，继承和多态的特性
3.C++中还有函数重载和引用等概念，C中没有
```

### 8.delete和delete[]区别

```c++
1.调用new []之后，释放内存使用delete[]
2.delete只调用一次析构函数，delete[]会调用每个成员的析构函数
```

### 9. C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等

```c++
1.C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++高。
2.C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法。
3.C++有指针，Java没有指针，只有引用。
4.JAVA和C++都有构造函数，但是C++有析构函数但是Java没有，因为java垃圾回收交给了jvm自己来做。
```

### 10.c++和python区别

```c++
1.python是脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python效率没有c++高
2.python库函数比c++多
3.python使用缩进，c++使用花括号
4.c++需要预先定义变量类型，python不需要
```

### 11.Struct和class的区别

```c++
1.struct的成员的访问权限默认是public，而class的成员默认是private；
2.struct的继承默认是publilc继承，而class的默认继承是private继承；
3.class可以作为模版，struct不可以
```

### 12.define和const的联系与区别

```c++
预处理指令包括条件编译、源文件包含、宏替换、行控制、抛错、杂注和空指令。
1.const修饰类的成员变量目标是常量不能被修改；
2.const修饰类的成员函数，表示该函数不会修改类的数据成员，不会调用其他非const的成员函数。
```

### 13.C++中static的用法和意义

```c++
堆区，栈区，代码区，全局数据区
1. 静态局部变量
用于函数体内部修饰变量，这种变量的生存期长于该函数。
  a.该变量在全局数据区分配内存(局部变量在栈区分配内存);
  b.在首次声明时被初始化，如果没有初始化值，默认为0，之后不再进行初始化;
  c.始终在全局数据区，但是作用域是局部作用域
  
2.静态全局变量,静态函数
定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见。
  a.不能被其他文件所用
  b.其他文件中可以有相同名字的函数或者变量

3.静态数据成员
	静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。静态数据成员只分配一次内存。静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，必须在类外初始化。

4.静态成员函数
  静态成员之间可以相互访问，但是不可以访问非静态；非静态可以随意调用静态。
  调用静态成员函数，可以用成员访问操作符调用静态成员函数,也可以用类名::函数名调用。
  没有this指针
```

### 14.typdef和define区别

```c++
1.define在预处理阶段执行，只是进行简单的替换
2.typdef是在编译时处理，是在自己的作用域给存在的类型一个别名
```

### 15.友元

```c++
(1) 友元关系不能被继承。
(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
(3) 友元关系不具有传递性。
  
友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。
  
友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。
  
在需要允许某些特定的非成员函数访问一个类的私有成员（及受保护成员），而同时仍阻止一般的访问的情况下，友元是可用的。
  class A
{
public:
    friend class C;                         //这是友元类的声明
private:
    int data;
};

class C             //友元类定义，为了访问类A中的成员
{
public:
    void set_show(int x, A &a) { a.data = x; cout<<a.data<<endl;}
};

int main(void)
{
    class A a;
    class C c;

    c.set_show(1, a);

    return 0;
}
```









## c++面试精华

### 指针

```c++
指针：
内存地址在32位系统和64位系统所占字节不一样。同一平台内存地址所占字节是一样的。
在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。

指针是一种数据类型，存储的数据是地址

解引用：取出指针指向的变量值

野指针，悬挂指针：指针定义时，没有初始化，int*p = (int)*oEsYSHSHJ; 随便赋值，玩意这一地址被使用ing就会有问题

指针的宽度：int *p = &a,占4个字节
跨度：int *p = &a; p++;跳4个字节

void* 类型指针：可以指向任意变量的内存空间，任何类型指针变量都能转换成void*
不要对其解引用，除非强转
主要作为函数的参数

const在*的左边和右边的不同

cout<<处理字符指针 不会使出地址
  
  
  
----在函数内部修改指针指向的变量需要传递地址
void myMewint(int *ptr) {
  ptr = new int;
}
void myNewint1(int **p) {
  *ptr = new int;
}
int main() {
  int *p = nullptr;
  myNewint(p);//不会改变p的指向
  myNewint1(&p);//会改变
}


```

![](/Users/jazz/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/6394cc7a89cec76754bc491c1319e3ff/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/Image/781642508668_.pic.jpg)



### 函数

```
函数：
分文件编写

防止头文件重复包含
#ifndef
#define
#endif

函数指针 int (*p)(参数1,参数2...) = 函数名//主要用在回调函数里面

宏函数 #DEFINE GETSUM(x,y) ((x) + (y))) //空间换时间

内联函数 

左值
右值：字面常量，包含多项的表达式

常量引用
const int & a = 10;//const int temp = 10; const int& a = temp;

内联函数 解决了宏函数的缺陷，不能对函数取地址


extern C{
//c,c++混合编程
}

```

### 类

```
为什么要有类的初始化列表？ 为了const和引用类型的变量，如果在构造函数里面赋值，之前已经分配了内存什么什么的，相当于修改了

类对象作为类成员：构造函数顺序，按照类对象在类中顺序初始化的

菱形继承：虚继承，解决了二义性，虚基类表，vbptr

父类的指针和引用可以指向子类的对象

静态联编，动态联编

动态多态：虚函数
静态多态：函数重载

虚函数实现原理：每一个类都会又一个虚函数表 记录虚函数的入口地址，懂？ 如果没有重写，虚函数指针vfptr就指向父类的虚函数的实现，如果重写了，就指向当前类的函数实现










```

## 问题

1.static  静态变量什么时候初始化

2.空指针也可以调用

```c++
#include <iostream>
using namespace std;
class animal{
public:
    animal(){
        cout<<"---"<<endl;
    }
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};
class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};
int main(){
    animal *pAn= nullptr;
    pAn->breathe();   // 输出：animal breathe haha
    fish *pFish = nullptr;
    pFish->breathe(); // 输出：fish bubble
    return 0;
}
//结果：没有执行构造函数
```

3.**malloc底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

### i++和++i的区别

1. **效率不同**：后置++执行速度比前置的慢。

2. **i++ 不能作为左值，而++i 可以**：

   ```c
   int i = 0;
   int *p1 = &(++i);//正确
   int *p2 = &(i++);//错误
   ++i = 1; //正确
   i++ = 1; //错误
   ```

3. 两者都不是原子操作。



#### 程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？

```
从低地址到高地址，一个程序由代码段、数据段、 BSS 段组成。

数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域。

代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。

BSS 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。

可执行程序在运行时又会多出两个区域：堆区和栈区。

堆区：动态申请内存用。堆从低地址向高地址增长。

栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。

最后还有一个文件映射区，位于堆和栈之间。

程序启动的过程：

操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。
加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。
加载器针对该程序的每一个动态链接库调用LoadLibrary
（1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。
（2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。
（3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3
（4）调用该动态链接库的初始化函数
初始化应用程序的全局变量，对于全局对象自动调用构造函数。
进入应用程序入口点函数开始执行。
```



#### 1.2.7 请简述一下atomoic内存顺序。

### 为什么没有虚构造函数

```
1.虚函数的原理就是维护虚函数表，通过这个表去找到虚函数的偏移地址。vptr的初始化是在构造函数之后，实现上违背。因为执行虚构造函数 肯定要去虚函数表里面找地址，但是，虚函数表都没有初始化呢
2.没必要，用父类的指针调用子类的构造函数？？
```

### 初始化列表和构造函数

```
第一种效率高，然后如果成员变量有是引用，const必须用这种方式
```



------

# 项目梳理

## WebServer











