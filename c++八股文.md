### 1. 指针和引用

```c++
1.指针可以为空，引用不可以
2.指针可以有多级
3.引用声明的时候 就必须初始化
4.自增运算含义不同，指针表示下一个变量，引用表示值自增
5.作为函数参数传递时的区别,使用指针的话需要解引用才能对参数做修改,而使用引用可以直接对参数进行修改
  （解引用就是返回内存地址中保存的值）
6.指针可以更换指向的对象或变量，引用不可以
7.指针有属于它自己的空间，引用的大小取决于被引用对象的大小
  
other
  引用参数使用const eg: 
	int a = 9;
	double recube(const double &a);
	recube(a+10);//会创建一个临时变量，如果不是用const会出错;同时也可以防止数据被无意修改

```

### 2. 传参数的时候什么时候用指针，什么时候用引用

```c++
1.对栈空间大小比较敏感（如递归）的时候使用引用。使用引用不需要创建临时变量，开销更小；
2.类对象作为参数传递时使用引用，这是C++类对象传递的标准方式。
3.需要返回函数内局部变量的地址的内存时使用指针。使用指针传参需要开辟内存，用完要记得释放指针。
  
  
指针传递参数本质上是值传递的方式，它所传递的是一个地址值。
在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。
  
other : 引用作为函数参数以及返回值的好处
	作为函数参数：效率高，可以对实参进行修改
  作为返回值：在内存中不产生被返回值的副本
    1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁
    2）不能返回函数内部new分配的内存的引用。

```

### 3. 堆和栈的区别

```c++
1.堆 由程序员释放 一般new delete
  
2.栈速度比堆快
操作系统在底层会对栈提供支持，会分配专门的寄存器存放栈的地址;
而堆的操作是由C/C++函数库提供的，在分配堆内存的时候，需要一定的算法寻找合适的内存大小，并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。
  
3.对于堆，频繁的new/delete会造成大量碎片，使程序效率降低。 对于栈，它是一个先进后出的队列，进出一一对应，不会产生碎片。
  
4.栈是一块连续的内存区域，堆是不连续的
  
5.堆的生长空间向上，地址越来越大；栈的生长空间向下，地址越来越小。---？？？
```

### 4.new和delete是如何实现的，new和malloc的异同

```c++
1.在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。
2.delete会调用对象的析构函数，然后调用free回收内存。
3.new只需要对象名，new还会根据调用对象的构造函数进行初始化,malloc还需要指定出空间
  
补充：被free之后，并不是立即返回给操作系统，因为为了避免频繁的系统调用，free会瘦的内存会被ptmalloc双链表保存起来，当用户下一次申请内存的时候，会从这些内存中返回合适的，同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。
```



### 5.linux下brk、mmap、malloc和new的区别

```

```



### 6.既然有了malloc/free，为什么还要new/delete？

```c++
1.对于内部数据类型，由于其没有构造函数和析构函数的要求，对于内部数据类型来讲，malloc/free和new/delete的作用是等价的，都是用来申请动态内存和释放内存。
2.对于非内部数据对象(eg：类对象)，只用malloc/free无法满足动态对象的要求。这是因为对象在创建的同时需要自动执行构造函数，对象在消亡之前要自动执行析构函数，而由于malloc/free是库函数而不是运算符，不在编译器的控制权限内，也就不能自动执行构造函数和析构函数。因此，不能将执行构造函数和析构函数的任务强加给malloc/free。所以，在c++中需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理和释放内存工作的运算符delete。

```

### 7.C和C++的区别

```c++
1.C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete
2.C面向过程， c++面向对象。c++有封装，继承和多态的特性
3.C++中还有函数重载和引用等概念，C中没有
```

### 8.delete和delete[]区别

```c++
1.调用new []之后，释放内存使用delete[]
2.delete只调用一次析构函数，delete[]会调用每个成员的析构函数
```

### 9. C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等

```c++
1.C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++高。
2.C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法。
3.C++有指针，Java没有指针，只有引用。
4.JAVA和C++都有构造函数，但是C++有析构函数但是Java没有，因为java垃圾回收交给了jvm自己来做。
```

### 10.c++和python区别

```c++
1.python是脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python效率没有c++高
2.python库函数比c++多
3.python使用缩进，c++使用花括号
4.c++需要预先定义变量类型，python不需要
```

### 11.Struct和class的区别

```c++
1.struct的成员的访问权限默认是public，而class的成员默认是private；
2.struct的继承默认是publilc继承，而class的默认继承是private继承；
3.class可以作为模版，struct不可以
```

### 12.define和const的联系与区别

```c++
预处理指令包括条件编译、源文件包含、宏替换、行控制、抛错、杂注和空指令。
1.const修饰类的成员变量目标是常量不能被修改；
2.const修饰类的成员函数，表示该函数不会修改类的数据成员，不会调用其他非const的成员函数。
```

### 13.C++中static的用法和意义

```c++
堆区，栈区，代码区，全局数据区
1. 静态局部变量
用于函数体内部修饰变量，这种变量的生存期长于该函数。
  a.该变量在全局数据区分配内存(局部变量在栈区分配内存);
  b.在首次声明时被初始化，如果没有初始化值，默认为0，之后不再进行初始化;
  c.始终在全局数据区，但是作用域是局部作用域
  
2.静态全局变量,静态函数
定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见。
  a.不能被其他文件所用
  b.其他文件中可以有相同名字的函数或者变量

3.静态数据成员
	静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。静态数据成员只分配一次内存。静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，必须在类外初始化。

4.静态成员函数
  静态成员之间可以相互访问，但是不可以访问非静态；非静态可以随意调用静态。
  调用静态成员函数，可以用成员访问操作符调用静态成员函数,也可以用类名::函数名调用。
```

### 14.typdef和define区别

```c++
1.define在预处理阶段执行，只是进行简单的替换
2.typdef是在编译时处理，是在自己的作用域给存在的类型一个别名
```

### 15.友元

```c++
(1) 友元关系不能被继承。
(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
(3) 友元关系不具有传递性。
  
友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。
  
友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。
  
在需要允许某些特定的非成员函数访问一个类的私有成员（及受保护成员），而同时仍阻止一般的访问的情况下，友元是可用的。
  class A
{
public:
    friend class C;                         //这是友元类的声明
private:
    int data;
};

class C             //友元类定义，为了访问类A中的成员
{
public:
    void set_show(int x, A &a) { a.data = x; cout<<a.data<<endl;}
};

int main(void)
{
    class A a;
    class C c;

    c.set_show(1, a);

    return 0;
}
```









## c++面试精华

```c++
指针：
内存地址在32位系统和64位系统所占字节不一样。同一平台内存地址所占字节是一样的。
在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。

指针是一种数据类型，存储的数据是地址

解引用：取出指针指向的变量值

野指针，悬挂指针：指针定义时，没有初始化，int*p = (int)*oEsYSHSHJ; 随便赋值，玩意这一地址被使用ing就会有问题

指针的宽度：int *p = &a,占4个字节
跨度：int *p = &a; p++;跳4个字节

void* 类型指针：可以指向任意变量的内存空间，任何类型指针变量都能转换成void*
不要对其解引用，除非强转
主要作为函数的参数

const在*的左边和右边的不同

cout<<处理字符指针 不会使出地址

```

![](/Users/jazz/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/6394cc7a89cec76754bc491c1319e3ff/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/Image/781642508668_.pic.jpg)





```
函数：
分文件编写
防止头文件重复包含

```

